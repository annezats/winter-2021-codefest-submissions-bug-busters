{"ast":null,"code":"var MoveFinger = function MoveFinger(entities, _ref) {\n  var touches = _ref.touches;\n  console.log(touches);\n  return entities;\n};\n\nexport { MoveFinger };","map":{"version":3,"sources":["/home/mming/Desktop/winter-2021-codefest-submissions-bug-busters/app/components/game/systems.js"],"names":["MoveFinger","entities","touches","console","log"],"mappings":"AAAA,IAAMA,UAAU,GAAG,SAAbA,UAAa,CAACC,QAAD,QAA2B;AAAA,MAAdC,OAAc,QAAdA,OAAc;AAgB9CC,EAAAA,OAAO,CAACC,GAAR,CAAYF,OAAZ;AACE,SAAOD,QAAP;AACD,CAlBD;;AAoBA,SAASD,UAAT","sourcesContent":["const MoveFinger = (entities, { touches }) => {\n  //\n  // //-- I'm choosing to update the game state (entities) directly for the sake of brevity and simplicity.\n  // //-- There's nothing stopping you from treating the game state as immutable and returning a copy..\n  // //-- Example: return { ...entities, t.id: { UPDATED COMPONENTS }};\n  // //-- That said, it's probably worth considering performance implications in either case.\n  //\n  // touches.filter(t => t.type === \"move\").forEach(t => {\n  //   let finger = entities[t.id];\n  //   if (finger && finger.position) {\n  //     finger.position = [\n  //       finger.position[0] + t.delta.pageX,\n  //       finger.position[1] + t.delta.pageY\n  //     ];\n  //   }\n  // });\nconsole.log(touches);\n  return entities;\n};\n\nexport { MoveFinger };\n"]},"metadata":{},"sourceType":"module"}