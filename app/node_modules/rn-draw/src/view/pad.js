import React from "react";
import { View, PanResponder, StyleSheet, Platform } from "react-native";
import Svg, { G, Surface, Path } from "react-native-svg";
import Pen from "../tools/pen";
import Point from "../tools/point";
const { OS } = Platform;
import BestGame from "../../../../components/game";
// import Bezier from '../tools/bezier'
export default class Whiteboard extends React.Component {
  constructor(props, context) {
    super(props, context);
    this.state = {
      tracker: 0,
      currentPoints: [],
      previousStrokes: [],
      newStroke: [],
      pen: new Pen(),
      lines:[]
    };

    this._panResponder = PanResponder.create({
      onStartShouldSetPanResponder: (evt, gs) => true,
      onMoveShouldSetPanResponder: (evt, gs) => true,
      onPanResponderGrant: (evt, gs) => this.onResponderGrant(evt, gs),
      onPanResponderMove: (evt, gs) => this.onResponderMove(evt, gs),
      onPanResponderRelease: (evt, gs) => this.onResponderRelease(evt, gs)
    });
    const rewind = props.rewind || function() {};
    //const next = props.next || function() {};
    const clear = props.clear || function() {};
    this._clientEvents = {
      rewind: rewind(this.rewind),
      clear: clear(this.clear)//add comma!!
      //next: next(this.next)
    };
  }

  rewind = () => {
    if (
      this.state.currentPoints.length > 0 ||
      this.state.previousStrokes.length < 1
    )
      return;
    let strokes = this.state.previousStrokes;
    strokes.pop();
    this.state.lines.pop()
    this.state.pen.rewindStroke();

    this.setState({
      previousStrokes: [...strokes],
      currentPoints: [],
      tracker: this.state.tracker - 1
    }, () => {
      this._onChangeStrokes([...strokes]);
    });
  };

  clear = () => {
    this.setState({
      previousStrokes: [],
      currentPoints: [],
      newStroke: [],
      tracker: 0
    }, () => {
      this._onChangeStrokes([]);
    });
    this.state.pen.clear();
    console.log("next");
  };

  //next =()=>{
    //console.log("next1");
  //};

  onTouch(evt) {
    let x, y, timestamp;
    [x, y, timestamp] = [
      evt.nativeEvent.locationX,
      evt.nativeEvent.locationY,
      evt.nativeEvent.timestamp
    ];
    let newPoint = new Point(x, y, timestamp);
    let newCurrentPoints = this.state.currentPoints;
    newCurrentPoints.push(newPoint);

    this.setState({
      previousStrokes: this.state.previousStrokes,
      currentPoints: newCurrentPoints,
      tracker: this.state.tracker
    });
    // {this.state.previousStrokes[0]
    //   ?(this.state.previousStrokes.forEach(arrayitem =>
    //      console.log(arrayitem.props.d)))
    //   :null};
    //   console.log('Bazinga');
    //   console.log(this.state.currentPoints);
    //   console.log("Helo");
  }

  onResponderGrant(evt) {
    this.onTouch(evt);
  }

  onResponderMove(evt) {
    this.onTouch(evt);
  }
  intersects=(a,b,c,d,p,q,r,s)=> {
    var det, gamma, lambda;
    det = (c - a) * (s - q) - (r - p) * (d - b);
    if (det === 0) {
      return false;
    } else {
      lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
      gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
      return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
    }
  };
  //returns true if check determines line intesects
      checkLine =()=>{
        if(this.state.previousStrokes.length>1){
           let currCoords=this.state.lines[this.state.lines.length-1].split("L");
           currCoords.shift();
           let k;
           for(k=0;k<currCoords.length-1;k++){
              let currX=currCoords[k].split(",")[0];
              let currY=currCoords[k].split(",")[1];
              let nextX=currCoords[k+1].split(",")[0];
              let nextY=currCoords[k+1].split(",")[1];
              for(let i=0;i<this.state.lines.length-1;i++){
                 let pastCoords=this.state.lines[i].split("L");
                 pastCoords.shift();
                 for(let j=0;j<pastCoords.length-1;j++){
                    let pastX1=pastCoords[j].split(",")[0];
                    let pastY1=pastCoords[j].split(",")[1];
                    let pastX2=pastCoords[j+1].split(",")[0];
                    let pastY2=pastCoords[j+1].split(",")[1];
                    if((pastX1==currX&&pastY1==currY)||(pastX2==currX&&pastY2==currY)){//check if endpoints match currCoords
                       return true;
                    }
                    if(this.intersects(currX,currY,nextX,nextY,pastX1,pastY1,pastX2,pastY2)){//check if currCoords line intersects pastCoords line
                       return true;
                    }
                    let leftSide=(currX-pastX1)/(pastX2-pastX1);
                    let rightSide=(currY-pastY1)/(pastY2-pastY1);
                    let minX=Math.min(pastX1,pastX2);
                    let maxX=Math.max(pastX1,pastX2);
                    let minY=Math.min(pastY1,pastY2);
                    let maxY=Math.max(pastY1,pastY2);
                    if((leftSide==rightSide)&&(currX>minX&&currX<maxX&&currY>minY&&currY<maxY)){//check if currCoord point on pastCoords line
                       return true;
                    }
                 }
              }
           }
           let currX=currCoords[k].split(",")[0];//this up to the next comment is to check if last index coord is in the line of last coords
           let currY=currCoords[k].split(",")[1];
           for(let i=0;i<this.state.lines.length-1;i++){
              let pastCoords=this.state.lines[i].split("L");
              pastCoords.shift();
              for(let j=0;j<pastCoords.length-1;j++){
                 let pastX1=pastCoords[j].split(",")[0];
                 let pastY1=pastCoords[j].split(",")[1];
                 let pastX2=pastCoords[j+1].split(",")[0];
                 let pastY2=pastCoords[j+1].split(",")[1];
                 if((pastX1==currX&&pastY1==currY)||(pastX2==currX&&pastY2==currY)){
                    return true;
                 }
                 let leftSide=(currX-pastX1)/(pastX2-pastX1);
                 let rightSide=(currY-pastY1)/(pastY2-pastY1);
                 let minX=Math.min(pastX1,pastX2);
                 let maxX=Math.max(pastX1,pastX2);
                 let minY=Math.min(pastY1,pastY2);
                 let maxY=Math.max(pastY1,pastY2);
                 if((leftSide==rightSide)&&(currX>minX&&currX<maxX&&currY>minY&&currY<maxY)){//check if currCoord point on pastCoords line
                    return true;
                 }
              }
           }//
        }
        return false;
     }
  onResponderRelease() {
    let strokes = this.state.previousStrokes;
    if (this.state.currentPoints.length < 1) return;
    let newElement = (
      <Path
        key={this.state.tracker}
        d={this.state.pen.pointsToSvg(this.state.currentPoints)}
        stroke={this.props.color || "#000000"}
        strokeWidth={this.props.strokeWidth || 4}
        fill="none"
      />
    );

    this.state.pen.addStroke(this.state.currentPoints);

    this.setState({
      previousStrokes: [...this.state.previousStrokes, newElement],
      currentPoints: [],
      tracker: this.state.tracker + 1
    }, () => {
      this._onChangeStrokes(this.state.previousStrokes);
      this.state.lines.push(this.state.previousStrokes[this.state.previousStrokes.length-1].props.d);
      console.log(this.state.lines);
      if(this.checkLine()){
         console.log("LINES detected");
         this.rewind();
      }
      //console.log(this.state.previousStrokes)
    });
  }

   _onChangeStrokes = (strokes) => {
      if(this.props.onChangeStrokes){
        this.props.onChangeStrokes(strokes);
      }
   }
  _onLayoutContainer = e => {
    this.state.pen.setOffset(e.nativeEvent.layout);
  };

  render() {
    return (
      <View
        onLayout={this._onLayoutContainer}
        style={[styles.drawContainer, this.props.containerStyle]}
      >
        <BestGame />
        <View style={styles.svgContainer} {...this._panResponder.panHandlers}>
          <Svg style={styles.drawSurface}>

            <G>
              {this.state.previousStrokes}
              <Path
                key={this.state.tracker}
                d={this.state.pen.pointsToSvg(this.state.currentPoints)}
                stroke={this.props.color || "#000000"}
                strokeWidth={this.props.strokeWidth || 4}
                fill="none"
              />

            </G>

          </Svg>

          {this.props.children}
        </View>
      </View>
    );
  }
}

let styles = StyleSheet.create({
  drawContainer: {
    flex: 1,
    display: "flex"
  },
  svgContainer: {
    flex: 1
  },
  drawSurface: {
    flex: 1
  }
});
